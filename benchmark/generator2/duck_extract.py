import duckdb
import re
from datetime import date, datetime

def duckdb_type_to_mysql(dtype: str) -> str:
    """Convert DuckDB data type to MySQL 8.0 compatible data type"""
    dtype = dtype.lower()
    if dtype.startswith('varchar') or dtype == 'string':
        return 'TEXT'
    if dtype.startswith('int') or dtype == 'integer':
        return 'INT'
    if dtype == 'bigint':
        return 'BIGINT'
    if dtype == 'double' or dtype == 'float':
        return 'DOUBLE'
    if dtype == 'boolean':
        return 'TINYINT(1)'
    if dtype == 'date':
        return 'DATE'
    if dtype == 'timestamp':
        return 'DATETIME'
    return 'TEXT'

def escape_sql_value(val):
    """Escape a value for safe SQL INSERT"""
    if val is None:
        return 'NULL'
    if isinstance(val, (date, datetime)):
        return f"'{val.isoformat()}'"
    if isinstance(val, str):
        val = val.replace("\\", "\\\\")  # Escape backslashes first
        val = val.replace("'", "''")     # Escape single quotes
        val = val.replace("\n", "\\n")
        val = val.replace("\r", "\\r")
        val = val.replace("\t", "\\t")
        val = val.replace("\0", "\\0")
        val = val.replace("\x1a", "\\Z")
        return f"'{val}'"
    return str(val)

def generate_create_table(con, table_name):
    """Generate CREATE TABLE SQL for MySQL 8.0 from DuckDB schema"""
    info = con.execute(f"PRAGMA table_info('{table_name}')").fetchall()
    columns = []
    for col in info:
        col_name = col[1]
        col_type = col[2]
        mysql_type = duckdb_type_to_mysql(col_type)
        col_def = f"`{col_name}` {mysql_type} DEFAULT NULL"
        columns.append(col_def)
    columns_sql = ",\n  ".join(columns)
    return f"CREATE TABLE `{table_name}` (\n  {columns_sql}\n);"


def validate_row(row):
    """Validate a row of data before generating SQL"""
    for val in row:
        if isinstance(val, str) and any(c in val for c in ['\0', '\x1a']):
            raise ValueError(f"Invalid character in string: {val}")
    return row

def generate_insert_statements(con, table_name):
    """One INSERT per row to avoid semicolon confusion"""
    rows = con.execute(f"SELECT * FROM {table_name}").fetchall()
    if not rows:
        return []

    columns = [desc[0] for desc in con.description]
    col_names = f"`{'`, `'.join(columns)}`"
    inserts = []

    for row in rows:
        validate_row(row)
        escaped = [escape_sql_value(v) for v in row]
        values = f"({', '.join(escaped)})"
        sql = f"INSERT INTO `{table_name}` ({col_names}) VALUES {values};"
        inserts.append(sql)

    return inserts

def export_tpcds_to_sql(filename, sf=0.01):
    """Export TPC-DS schema and data from DuckDB to MySQL-compatible SQL dump"""
    con = duckdb.connect()
    con.execute("INSTALL tpcds;")
    con.execute("LOAD tpcds;")
    con.execute(f"CALL dsdgen(sf={sf});")

    tables = con.execute("""
        SELECT table_name FROM information_schema.tables
        WHERE table_schema = 'main'
        ORDER BY table_name
    """).fetchall()

    with open(filename, 'w', encoding='utf-8') as f:
        f.write(f"-- TPC-DS Data dump for MySQL 8.0 generated by DuckDB (scale factor {sf})\n\n")
        for (table_name,) in tables:
            print(f"Exporting table: {table_name}")
            create_sql = generate_create_table(con, table_name)
            f.write(create_sql + "\n\n")
            inserts = generate_insert_statements(con, table_name)
            for ins in inserts:
                f.write(ins + "\n")

if __name__ == "__main__":
    export_tpcds_to_sql("tpcds_data_dump.sql", sf=0.01)
    print("Export completed! File: tpcds_data_dump.sql")

